
# SRP: Single Responsobility Principle
Принцип единственной ответственности

#### Основная суть
модуль имеет одну и только одну причину для изменения

##### ЧТО НА САМОМ ДЕЛЕ ИМЕЕТСЯ ВВИДУ
Модуль должен отвечать за одного и только за одного актора*
актор-группа людей

#### Объяснение
У нас есть несколько груп лиц, которые используют одну и ту же функцию для разных целей. Одному актору понадобилось, что-то изменить в коде, но это сломало код для второго актора. Чтобы это избежать, нужно разделять функционал для каждого актора.

##### Варианты решения
- Создание отдельных классов под каждого актора
- Использовать шаблон фасад(1 класс, но он обращается к трём разным классам поменьше)

# OCP: Open - Closed Principle
принцип открытости/закрытости

#### Основная суть
Программные сущности(классы) должны быть открыты для расширения и закрыты для изменения

##### Объяснение
Если у нас есть базовый класс, то мы не должны при любом удобной случае его изменять, а наоборот под каждую новую ситуацию создавать новый класс, который будет наследоваться от базового класса


# LSP: Liskov Substitution Principle
принцип подстановки Барбары Лисков

#### Основная суть
Если для каждого объекта о1 типа S существует такой объект о2 типа Т, что для всех программ Р, определённых в терминале T, поведение Р не изменяется при подстановке о1 вместо о2, то S является подтипом Т.

##### Объяснение
У нас есть класс *License*, который является родителем для классов *Personal Licence(PL)* и *Business Licence(BL)*. И если при обращении из класса Billing к Licence мы можем использовать без ошибок как PK, так и BL, то LSP соблюдается.


# ISP Interface Segregation Principle 
Принцип разделения интерфейсов

#### Основная суть
Избегать зависимости от всего, что не используется

##### Объяснение
Если какая-то часть интерфейса не использует вторую часть, но зависит от неё, то нужно разделить эти интерфейсы

# DIP Dependecy Inversion Principle
Принцип инверсии зависимости

#### Основная суть
Код реализующий высокоуровневую политику, не должен зависеть от кода, реализующего низкоуровневые детали. Напротив, детали должны зависеть от политики

#### Важные правила
- Не ссылайтесь на изменчивые конкретные классы
	Ссылаться нужно на абстрактные классы
- Не наследуйте изменчивые конкретные классы
- Не переопределяйте конкретные функции
	Переопределением функций, вы не устраняете зависимость, а фактически наследуем. Для управления подобными зависимостями нужно сделать функцию абстрактной и создать несколько её реализаций
- Никогда не ссылайтесь на имена конкретных и изменчивых сущностей
